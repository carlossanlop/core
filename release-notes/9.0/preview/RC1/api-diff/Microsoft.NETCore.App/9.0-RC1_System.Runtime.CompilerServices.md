# System.Runtime.CompilerServices

``` diff
 namespace System.Runtime.CompilerServices {
+    public class CallConvSwift {
+        public CallConvSwift();
+    }
-    [AttributeUsageAttribute(AttributeTargets.Struct, AllowMultiple=false)]
-    [EditorBrowsableAttribute(EditorBrowsableState.Never)]
-    public sealed class InlineArrayAttribute : Attribute
+    [AttributeUsageAttribute(AttributeTargets.Struct, AllowMultiple=false)]
+    public sealed class InlineArrayAttribute : Attribute
+    [AttributeUsageAttribute(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
+    public sealed class OverloadResolutionPriorityAttribute : Attribute {
+        public OverloadResolutionPriorityAttribute(int priority);
+        public int Priority { get; }
+    }
+    [AttributeUsageAttribute(AttributeTargets.Parameter, Inherited=true, AllowMultiple=false)]
+    public sealed class ParamCollectionAttribute : Attribute {
+        public ParamCollectionAttribute();
+    }
     public static class RuntimeFeature {
+        public const string ByRefLikeGenerics = "ByRefLikeGenerics";
-        public static bool IsDynamicCodeCompiled { get; }
+        [FeatureGuardAttribute(typeof(RequiresDynamicCodeAttribute))]
+        public static bool IsDynamicCodeCompiled { get; }
-        public static bool IsDynamicCodeSupported { get; }
+        [FeatureSwitchDefinitionAttribute("System.Runtime.CompilerServices.RuntimeFeature.IsDynamicCodeSupported")]
+        public static bool IsDynamicCodeSupported { get; }
     }
     public static class RuntimeHelpers {
+        public static object? Box(ref byte target, RuntimeTypeHandle type);
+        public static int SizeOf(RuntimeTypeHandle type);
     }
     public static class Unsafe {
-        public static TTo BitCast<TFrom, TTo>(TFrom source) where TFrom : struct where TTo : struct;
+        public static TTo BitCast<TFrom, TTo>(TFrom source);
-        public static T ReadUnaligned<T>([RequiresLocationAttribute] ref byte source);
+        public static T ReadUnaligned<T>([RequiresLocationAttribute, ScopedRefAttribute] ref byte source);
     }
 }
```

